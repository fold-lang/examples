
--
-- # Modules
--
-- * 1.0 Definition
-- * 2.0 Loading and Opening Modules
-- * 3.0 Functors

--
-- ## 2.0 Loading and Opening Modules
--

--
-- Load a module
--
-> load OS

-- Only the module can be used
-> user = OS.getenv "USER"
user :: String = "dmr"


--
-- Load a module using an alias
--
-> load OS as POSIX

-- Only the alias can be used
-> user = POSIX.getenv "USER"
user :: String = "dmr"

-- Using module name directly will not work
-> user = OS.getenv "USER"
 * Error: Unbound module OS


--
-- Load multiple modules
--
-> load OS, Sys

-- Both modules can be used.
-> user = OS.getenv "USER"
user :: String = "dmr"
-> Sys.time ()
:: Float = 0.276656


--
-- Load a module and some symbols.
--
-> load OS with: [getenv, getuid as uid]

-- The `getenv` and `getuid` symbols can be used directly.
-> user, uid = getenv "USER", uid ()
user :: String = "dmr"
 uid :: Int = 501
-- The `OS` was also loaded and can be used.
-> OS.getguid ()
:: Int = 20

--
-- Open all module symbols
--
-- The usage of `open` without selection is discouraged since conflicting
-- symbols may be introduced in the scope. In which case, for a conflicting
-- name, the last imported definition will be used.
--
-> open OS

-- All module symbols can be used directly.
-> getuid ()
:: Int = 501
-> getgid ()
:: Int = 20
-- Opened modules are not loaded.
-> OS.getuid ()
 * Error Unbound module OS


--
-- Open only some module symbols
--
-> open OS only: [getcwd as cwd]

-- Only the symbols `cwd` was opened from the module.
-> cwd ()
:: String = "/home/dmr"

-- Open all module symbols with exceptions
open OS hide: [mkdir, mkfifo]



--
-- Interfaces
--

protocol Animal T {
    init :: String -> T
    name :: T -> String
    talk :: T -> String
}

data Dog (name : String)

instance Animal Dog {
    init ~name = Dog name
    name dog = dog.name
    talk dog = "woof!"
}

laika : Dog = init (name: "Laika Kosmonavt")
name laika == "Laika Kosmonavt"
talk laika == "woof!"

-- Module User

protocol Show T {
    show : T -> String
}

type User = (name: String, birthday: Date, profession: String)

instance Show User {
    show (u: user) -> String = u.name
}


protocol Show T {
    show : T -> String
}


instance Show {Eq T} :: (List a)
    show
end

instance Show {Eq T} :: (Int -> String -> (Person, a))
    show
end

show (u::User) = u.name

show (M::Show) (x::M a) = u.name


map `round [1, 2, 3]

alice :: User =
  { name: "Alice",
    birthday: 14/08/2014,
    profession: `cat }

show alice


type ordering = LT | EQ | GT

protocol Comparable a
    function compare :: a -> a -> ordering
end

instance Comparable int
    function compare a b
           | a == b -> EQ
           | a >  b -> GT
           | a <  b -> LT
    end
end


----

type ordering = LT | EQ | GT

protocol Comparable a:
    compare :: a -> a -> ordering

instance Comparable Int:
    compare x y =
        if | x == y -> EQ
           | x >  y -> GT
           | x <  y -> LT

instance Comparable User =
    compare x y = compare x.name y.name


module User =
    type user = ...
    compare x y =



-- // --



module JSONCodec n do
    Log.info "Will calculate factorial of {n}"
    (n == 0) ? 1 : n * factorial (n - 1)
end

interface Codec a =
    encode :: a -> Result Data
    decode :: Data -> Result a
end

module Codec Json =
    encode = String x => "\"{x}\""
           | Object x => surround x with ('{', '}')
           | List xs  => surround (join (map encode xs) with: ',')
                             with: '"'
end

module JSONCodec n =
    Log.info "Will calculate factorial of {n}"
    (n == 0) ? 1 : n * factorial (n - 1)
end

module JSONCodec n:
    Log.info "Will calculate factorial of {n}"
    (n == 0) ? 1 : n * factorial (n - 1)
end

JSONCodec n = module
    Log.info "Will calculate factorial of {n}"
    (n == 0) ? 1 : n * factorial (n - 1)
end

module JSONCodec n = {
    Log.info "Will calculate factorial of {n}"
    (n == 0) ? 1 : n * factorial (n - 1)
}

JSONCodec n = module {
    Log.info "Will calculate factorial of {n}"
    (n == 0) ? 1 : n * factorial (n - 1)
}

