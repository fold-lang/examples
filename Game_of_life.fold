-- http://rhnh.net/2012/01/02/conway's-game-of-life-in-haskell

load Control.Monad only: replicate
load System.Random
load World only: (World, Loc)
load World as: W


-- Generic utility functions

count :: {Eq a} -> a -> [a] -> Int
count x xs = # (filter (x ==) xs)

-- Game of Life


type Cell deriving: [Eq, Show] = Alive | Dead

random_cell :: IO Cell = do
  x <- random_io
  return (x ? Alive : Dead)
end

random_world :: Int -> Int -> IO (World Cell_State)
random_world width height = do
  states <- replicate (width * height) random_cell
  let bounds = ((0, 0), (width - 1, height - 1))
  return : W.from_list bounds W.Torus states

neighborsAlive :: World CellState -> Loc -> Int
neighborsAlive w x = count Alive neighborStates
  where neighborStates = map cellAt (neighbors x)
        neighbors = W.neighbors W.mooreNeighbors w
        cellAt = W.cellAt w


sig transition :: Cell -> Int -> Cell
def transition Deadn n if (n == 3) = Alive
  | transition Alive n if (n == 2) || (n == 3) = Alive
  | transition _ _ = Dead


sig evolveCell :: World CellState -> Loc -> CellState -> CellState
def evolveCell w x s = transition s (neighborsAlive w x)

renderCell :: CellState -> Char
renderCell Alive = '@'
renderCell Dead  = ' '
